<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Flappy (Canvas Textures)</title>
<style>
  html,body{height:100%;margin:0;background:#6ec2e0;display:flex;align-items:center;justify-content:center}
  #wrapper{width:100%;max-width:480px;height:100vh;display:flex;align-items:center;justify-content:center}
  canvas{background:#6ec2e0;display:block;border:2px solid #111;border-radius:8px}
  .overlay{position:fixed;left:10px;top:10px;color:white;font-family:Arial,Helvetica,sans-serif;text-shadow:0 1px 2px rgba(0,0,0,.6)}
</style>
</head>
<body>
<div id="wrapper">
  <canvas id="game" width="320" height="480"></canvas>
</div>
<div class="overlay" id="hint">Tap / Click / Space — Jump</div>

<script>
(() => {
  const baseW = 320, baseH = 480;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // HiDPI scaling
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    // make canvas fill wrapper while preserving aspect ratio
    const wrapper = document.getElementById('wrapper');
    const maxW = wrapper.clientWidth;
    const maxH = wrapper.clientHeight;
    let scale = Math.min(maxW / baseW, maxH / baseH);
    if (scale === Infinity) scale = 1;
    canvas.style.width = Math.round(baseW * scale) + 'px';
    canvas.style.height = Math.round(baseH * scale) + 'px';
    canvas.width = Math.round(baseW * dpr);
    canvas.height = Math.round(baseH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Game state
  let birdY = baseH * 0.45, birdVel = 0, birdX = 70, birdSize = 32;
  const gravity = 0.45, flapImpulse = -8;
  const pipeGap = 130, pipeW = 58, pipeSpeedBase = 2.2;
  let pipes = [];
  let score = 0, best = 0;
  let running = true;
  let gameOver = false;
  let tick = 0;

  // Parallax elements: clouds
  const clouds = [];
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * baseW,
      y: Math.random() * (baseH * 0.45),
      s: 0.6 + Math.random() * 1.1,
      vx: 0.2 + Math.random() * 0.6,
      puff: Math.floor(3 + Math.random()*4)
    });
  }

  // Offscreen bird frames (wing up, mid, down) — pixel/painterly style
  const birdFrames = [];
  (function createBirdFrames(){
    const size = 48;
    for (let f = 0; f < 3; f++){
      const oc = document.createElement('canvas');
      oc.width = size; oc.height = size;
      const octx = oc.getContext('2d');

      // simple pixel-esque bird: circle body + wing frame offset
      octx.save();
      // body
      octx.translate(size/2, size/2);
      octx.scale(0.9,0.9);
      // body shadow
      octx.beginPath();
      octx.arc(0,4,16,0,Math.PI*2);
      octx.fillStyle = 'rgba(0,0,0,0.12)';
      octx.fill();

      // main body
      const grad = octx.createLinearGradient(-12,-12,12,12);
      grad.addColorStop(0,'#ffd54a');
      grad.addColorStop(1,'#ffb300');
      octx.beginPath();
      octx.arc(0,0,14,0,Math.PI*2);
      octx.fillStyle = grad;
      octx.fill();

      // cheek
      octx.beginPath();
      octx.arc(8,2,4,0,Math.PI*2);
      octx.fillStyle = '#ff8a80';
      octx.fill();

      // beak (simple triangle)
      octx.beginPath();
      octx.moveTo(14,-1);
      octx.lineTo(22,0);
      octx.lineTo(14,6);
      octx.closePath();
      octx.fillStyle = '#ff8f00';
      octx.fill();
      octx.lineWidth = 0.5;
      octx.strokeStyle = 'rgba(0,0,0,0.08)';
      octx.stroke();

      // eye
      octx.beginPath();
      octx.arc(-3,-3,3,0,Math.PI*2);
      octx.fillStyle='#111';
      octx.fill();
      octx.beginPath();
      octx.arc(-4,-4,1.2,0,Math.PI*2);
      octx.fillStyle='#fff';
      octx.fill();

      // wing position depends on frame f
      const wingRot = (f - 1) * 0.45; // -0.45, 0, 0.45
      octx.save();
      octx.rotate(wingRot);
      octx.beginPath();
      octx.ellipse(-4,8,8,5,0,0,Math.PI*2);
      octx.fillStyle = '#ffcc33';
      octx.fill();
      octx.restore();

      octx.restore();
      birdFrames.push(oc);
    }
  })();

  // make first pipe
  pipes.push({ x: baseW + 20, h: randPipeHeight() });

  function randPipeHeight(){
    return 50 + Math.random() * (baseH - 200 - pipeGap);
  }

  // Controls (keyboard + pointer)
  function flap(){
    if (!gameOver) {
      birdVel = flapImpulse;
    } else {
      // restart
      reset();
    }
  }
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.key === ' ') { e.preventDefault(); flap(); }
  });
  // pointer covers both mouse and touch
  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    flap();
  }, {passive:false});

  // prevent mobile from bouncing on touch
  document.addEventListener('touchmove', (e) => { if (e.target === canvas) e.preventDefault(); }, {passive:false});

  // Reset game
  function reset(){
    pipes = [{ x: baseW + 20, h: randPipeHeight() }];
    birdY = baseH * 0.45; birdVel = 0;
    score = 0; gameOver = false; running = true; tick = 0;
  }

  // Draw background gradient and moving clouds
  function drawBackground(ctx){
    // sky gradient
    const g = ctx.createLinearGradient(0,0,0,baseH);
    g.addColorStop(0,'#80d3f8');
    g.addColorStop(1,'#70c5ce');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,baseW,baseH);

    // sun glow
    const sunX = baseW * 0.14, sunY = baseH * 0.12;
    const sg = ctx.createRadialGradient(sunX,sunY,5,sunX,sunY,120);
    sg.addColorStop(0,'rgba(255,250,200,0.9)');
    sg.addColorStop(1,'rgba(255,250,200,0)');
    ctx.fillStyle = sg;
    ctx.fillRect(0,0,baseW,baseH);

    // clouds (parallax)
    for (let c of clouds){
      c.x += c.vx * (pipeSpeedBase / 1.8);
      if (c.x - 120 > baseW) c.x = -140;
      drawCloud(ctx, c.x, c.y, c.s, c.puff);
    }
  }

  function drawCloud(ctx, x, y, scale = 1, puff = 4){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale, scale);
    // soft shadow
    ctx.beginPath();
    ctx.ellipse(0,0,48,20,0,0,Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    for (let i = 0; i < puff; i++){
      const px = (i - (puff-1)/2) * 22;
      ctx.beginPath();
      ctx.arc(px, 0 + Math.sin(i + performance.now()/800)*2, 22, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Draw pipes procedurally (with top cap & bottom cap)
  function drawPipe(ctx, x, topH){
    // top pipe (downward)
    const capH = 14;
    // body gradient
    const g1 = ctx.createLinearGradient(x,0,x+pipeW,0);
    g1.addColorStop(0,'#2e7d32');
    g1.addColorStop(1,'#1b5e20');
    ctx.fillStyle = g1;
    ctx.fillRect(x, 0, pipeW, topH);

    // highlight lines
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fillRect(x+4, 4, 6, Math.max(6, topH-8));

    // cap
    ctx.fillStyle = '#184d13';
    ctx.beginPath();
    ctx.moveTo(x - 4, topH);
    ctx.lineTo(x + pipeW + 4, topH);
    ctx.lineTo(x + pipeW + 2, topH + capH);
    ctx.lineTo(x - 2, topH + capH);
    ctx.closePath();
    ctx.fill();

    // bottom pipe (upward) will be drawn outside this function by caller with y = topH + gap
    // add subtle shadow
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    ctx.fillRect(x - 2, topH - 6, pipeW + 4, 4);
  }

  // Ground repeating pattern
  function drawGround(ctx, offsetX){
    const groundTop = baseH - 64;
    // base soil
    ctx.fillStyle = '#b38649';
    ctx.fillRect(0, groundTop, baseW, 64);

    // small repeating tiles/rectangles to look textured
    const tileW = 16, tileH = 12;
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    for (let x = -offsetX % tileW - tileW; x < baseW; x += tileW){
      for (let y = groundTop; y < baseH; y += tileH){
        if (Math.random() < 0.02) continue; // random holes
        ctx.fillRect(x, y, tileW - 4, tileH - 6);
      }
    }

    // grass rim
    ctx.fillStyle = '#2e7d32';
    ctx.fillRect(0, groundTop, baseW, 8);
    // grass blades
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    for (let x = -offsetX % 12; x < baseW; x += 12){
      ctx.fillRect(x + 8, groundTop - 6, 2, 6);
    }
  }

  // Collision helper
  function aabbOverlap(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  // Main loop
  function updateAndRender(){
    tick++;
    // physics update if running
    if (!gameOver){
      birdVel += gravity;
      birdY += birdVel;

      // move pipes left
      for (let p of pipes) p.x -= pipeSpeedBase;

      // spawn
      const last = pipes[pipes.length-1];
      if (last.x < baseW - 140) {
        pipes.push({ x: baseW + 20, h: randPipeHeight() });
      }
      // remove and score
      if (pipes.length && pipes[0].x < -pipeW) {
        pipes.shift();
        score++;
        if (score > best) best = score;
      }

      // collisions with pipes
      for (let p of pipes) {
        const topH = p.h;
        const bottomY = topH + pipeGap;
        // bird bbox approximate
        const bx = birdX, by = birdY, bw = birdSize*0.8, bh = birdSize*0.8;
        if (aabbOverlap(bx,by,bw,bh, p.x, 0, pipeW, topH) ||
            aabbOverlap(bx,by,bw,bh, p.x, bottomY, pipeW, baseH - bottomY - 64)) {
          gameOver = true;
        }
      }
      // ground or top
      if (birdY + birdSize*0.6 > baseH - 64 || birdY < -8) {
        gameOver = true;
        if (birdY < -8) birdY = -6;
      }
    }

    // ---- DRAW ----
    // clear
    ctx.clearRect(0,0,baseW,baseH);

    // background
    drawBackground(ctx);

    // pipes
    for (let p of pipes) {
      drawPipe(ctx, p.x, p.h);
      // bottom pipe body
      const by = p.h + pipeGap;
      const g2 = ctx.createLinearGradient(p.x, by, p.x + pipeW, by + baseH);
      g2.addColorStop(0,'#2e7d32');
      g2.addColorStop(1,'#1b5e20');
      ctx.fillStyle = g2;
      ctx.fillRect(p.x, by, pipeW, baseH - by - 64);

      // bottom cap
      ctx.fillStyle = '#184d13';
      ctx.beginPath();
      ctx.moveTo(p.x - 4, by);
      ctx.lineTo(p.x + pipeW + 4, by);
      ctx.lineTo(p.x + pipeW + 2, by - 14);
      ctx.lineTo(p.x - 2, by - 14);
      ctx.closePath();
      ctx.fill();

      // slight highlight
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(p.x + 4, by + 6, 6, Math.max(6, baseH - by - 80));
    }

    // ground
    drawGround(ctx, tick*1.2);

    // bird animation frame
    const frameIndex = Math.floor(tick / 6) % birdFrames.length;
    const bf = birdFrames[frameIndex];
    // draw shadow
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.beginPath();
    ctx.ellipse(birdX + birdSize/2, birdY + birdSize*0.9, birdSize*0.5, birdSize*0.18, 0,0,Math.PI*2);
    ctx.fillStyle = '#000';
    ctx.fill();
    ctx.restore();

    // draw bird rotated slightly by velocity
    ctx.save();
    const tilt = Math.max(-0.6, Math.min(0.6, birdVel * 0.04));
    ctx.translate(birdX + birdSize/2, birdY + birdSize/2);
    ctx.rotate(tilt);
    ctx.drawImage(bf, -birdSize/2, -birdSize/2, birdSize, birdSize);
    ctx.restore();

    // Score UI
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(8,8,80,30);
    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.fillText('Score: ' + score, 12, 30);

    // best
    ctx.fillStyle = 'rgba(0,0,0,0.14)';
    ctx.fillRect(baseW - 110, 8, 100, 30);
    ctx.fillStyle = '#fff';
    ctx.fillText('Best: ' + best, baseW - 106, 30);

    // Game over text
    if (gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(24, baseH/2 - 56, baseW - 48, 110);
      ctx.fillStyle = '#ff6b6b';
      ctx.font = 'bold 28px Arial';
      ctx.fillText('GAME OVER', 56, baseH/2 - 14);
      ctx.fillStyle = '#fff';
      ctx.font = '14px Arial';
      ctx.fillText('Tap / Click / Space — Restart', 48, baseH/2 + 12);
      ctx.font = '12px Arial';
      ctx.fillStyle = '#ffd';
      ctx.fillText('Score: ' + score, baseW/2 - 22, baseH/2 + 44);
    }

    // loop
    if (running) requestAnimationFrame(updateAndRender);
  }

  // start
  reset();
  requestAnimationFrame(updateAndRender);
})();
</script>
</body>
</html>
